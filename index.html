<!doctype html>
<html lang="sk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#ffffff">

  <title>Synchronized MP3 player — STRICT sync only</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:24px;color:#111}
    .card{max-width:720px;padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    label,select,button{display:block;margin:8px 0}
    #status{margin-top:12px;font-size:0.95rem;color:#333}
    .controls{margin-top:10px}
    button{padding:10px 14px;border-radius:8px;border:1px solid #ddd;background:#fafafa;cursor:pointer}
    /* Skryjeme audio UI úplne */
    audio{display:none !important}
  </style>
</head>
<body>
  <div class="card">
    <h2>Synchronized MP3 player — iba synchronizované prehrávanie</h2>
    <p>Na tejto strane je možné prehrávať zvuk <strongvýhradne</strong> synchronizovane. Je tu len jedno tlačidlo <em>Pustiť (synchronizovane)</em>. Ak sa niekto pokúsi preskočiť alebo spustiť zvuk iným spôsobom, prehrávanie sa okamžite vráti na správne synchronizované miesto.</p>

    <label for="person">Meno:</label>
    <select id="person" aria-label="Vyberte meno"></select>

    <div class="controls">
  <button id="playBtn">Pustiť (synchronizovane)</button>
  <button id="downloadBtn" type="button">Stiahnuť</button>
  <button id="clearCacheBtn" type="button">Vymazať cache</button>
</div>




    <div id="status">Stav: pripravený</div>

<!-- progress panel -->
<div id="progressPanel" aria-hidden="false" style="margin-top:12px;">
  <div style="display:flex;align-items:center;gap:12px;">
    <div id="timeText" style="min-width:120px;font-family:monospace">00:00 / 00:00</div>
    <progress id="progressBar" value="0" max="1" style="flex:1;height:12px;border-radius:6px;"></progress>
  </div>
</div>


    <audio id="player" preload="metadata"></audio>

    <hr />
    <p style="font-size:0.9rem;color:#555">Konfigurácia v kóde: objekt <code>tracks</code> (mapovanie meno → cesta k mp3) a <code>referenceTime</code> ("HH:MM").</p>
  </div>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js')
    .then(reg => console.log('SW registered', reg.scope))
    .catch(err => console.warn('SW reg failed', err));
}

</script>

<script>
// ---------- KONFIGURÁCIA (upraviť v kóde) ----------
const tracks = {
  "Adam": "audio/test.mp3",
  "Eva":  "audio/test.mp3"
};
const referenceTime = "02:00"; // format "HH:MM"
const RESYNC_INTERVAL_MS = 3000; // kontrola každé 3s
const RESYNC_TOLERANCE_S = 0.4;  // ak rozdiel väčší než 0.4s, prepíše sa
// ---------- KONIEC KONFIGURÁCIE ----------

const selectEl = document.getElementById('person');
const playBtn = document.getElementById('playBtn');
const statusEl = document.getElementById('status');
const audio = document.getElementById('player');
const downloadBtn = document.getElementById('downloadBtn');
const clearCacheBtn = document.getElementById('clearCacheBtn');
const timeText = document.getElementById('timeText');
const progressBar = document.getElementById('progressBar');
audio.setAttribute('playsinline', ''); // iOS inline behavior
audio.preload = 'auto';                // prednačítanie meta + data
// Media Session: zobrazenie ovládacích prvkov v notifikáciách / lock-screene
if ('mediaSession' in navigator) {
  navigator.mediaSession.metadata = new MediaMetadata({
    title: 'Synchronized Audio',
    artist: selectEl.value || '',
    album: '',
    artwork: [
      // voliteľné: { src: '/icons/icon-96.png', sizes: '96x96', type: 'image/png' }
    ]
  });

  navigator.mediaSession.setActionHandler('play', () => { stopPlaybackCleanup(); playSynchronized(); });
  navigator.mediaSession.setActionHandler('pause', () => { stopPlaybackCleanup(); audio.pause(); });
  // ostatné handlery (seekbackward/seekforward) ignorujeme alebo zablokujeme
  navigator.mediaSession.setActionHandler('seekbackward', null);
  navigator.mediaSession.setActionHandler('seekforward', null);
  navigator.mediaSession.setActionHandler('seekto', null);
}


// pomocná funkcia pre pekné formátovanie mm:ss alebo h:mm:ss pri potrebe
function formatTime(s){
  if(!isFinite(s) || s < 0) s = 0;
  s = Math.floor(s);
  const hh = Math.floor(s / 3600);
  const mm = Math.floor((s % 3600) / 60);
  const ss = s % 60;
  if(hh > 0) return `${hh}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
}

// aktualizuje progress UI podľa aktuálneho stavu audio
function updateProgressUI(){
  const dur = isFinite(audio.duration) ? audio.duration : 0;
  const cur = isFinite(audio.currentTime) ? audio.currentTime : 0;
  timeText.textContent = `${formatTime(cur)} / ${formatTime(dur)}`;
  progressBar.value = dur > 0 ? (cur / dur) : 0;
}

  
let currentBlobUrl = null;
let resyncTimer = null;
let syncRequested = false; // príznak, že play bol iniciovaný naším sync flow
let playPendingTimeout = null;

function setStatus(txt){ statusEl.textContent = 'Stav: ' + txt; }

// naplni select
function populateSelect(){
  Object.keys(tracks).forEach(name => {
    const opt = document.createElement('option'); opt.value = name; opt.textContent = name; selectEl.appendChild(opt);
  });
}

function parseReference(){
  const [hh, mm] = (referenceTime || '00:00').split(':').map(Number);
  const ref = new Date(); ref.setHours(hh, mm || 0, 0, 0); return ref.getTime();
}

// ---------- CACHE MANAGEMENT: on-demand caching + LRU eviction ----------

const CACHE_NAME = 'synchronized-mp3-cache-v2';
// Maximálny objem uložených audio súborov v bajtoch (prispôsobte podľa potreby)
const MAX_CACHE_BYTES = 700 * 1024 * 1024; // 700 MB
// Maximálna veľkosť jedného súboru (voliteľné)
const MAX_SINGLE_FILE_BYTES = 2 * 1024 * 1024 * 1024; // 2 GB (príklad)

// Pomocná: uloží meta záznam do cache ako JSON pod kľúč '__meta__' + url
async function putMeta(cache, url, size) {
  const meta = { url, size, ts: Date.now() };
  const metaReq = new Request('__meta__' + url);
  const metaResp = new Response(JSON.stringify(meta), { headers: { 'Content-Type': 'application/json' }});
  await cache.put(metaReq, metaResp);
}

// Pomocná: načíta všetky meta záznamy z cache a vráti pole {url,size,ts}
async function listCacheMetas(cache) {
  const keys = await cache.keys();
  const metas = [];
  for (const req of keys) {
    const key = req.url || req; // v niektorých prostrediach req je Request
    // we stored meta under Request('__meta__' + url) — match by URL path ending
    if (req.url && req.url.includes('__meta__')) {
      try {
        const resp = await cache.match(req);
        if (!resp) continue;
        const j = await resp.json();
        if (j && j.url) metas.push(j);
      } catch (e) { /* ignore malformed */ }
    }
  }
  return metas;
}

// Vypočíta aktuálne miesto obsadené cache (sčítaním meta.size)
async function computeCacheUsage(cache) {
  const metas = await listCacheMetas(cache);
  let total = 0;
  for (const m of metas) total += (m.size || 0);
  return { total, metas };
}

// Urob LRU eviction: zmaž najstaršie meta + audio kým total <= limit
async function enforceCacheLimit(maxBytes) {
  const cache = await caches.open(CACHE_NAME);
  const { total, metas } = await computeCacheUsage(cache);
  if (total <= maxBytes) return { total, removed: 0 };

  // zoradíme podľa ts asc (najstaršie prvé)
  metas.sort((a,b)=> (a.ts||0) - (b.ts||0));
  let curTotal = total;
  let removed = 0;
  for (const m of metas) {
    if (curTotal <= maxBytes) break;
    try {
      await cache.delete(new Request(m.url));
      await cache.delete(new Request('__meta__' + m.url));
      curTotal -= (m.size || 0);
      removed++;
    } catch(e) {
      console.warn('Eviction failed for', m.url, e);
    }
  }
  return { total: curTotal, removed };
}

// Hlavná funkcia: stiahni a ulož do cache len na požiadanie, spolu s meta, a potom vynúť limit
async function fetchAndCacheIfNeeded(name){
  const url = tracks[name];
  if(!url) throw new Error('Neznáme meno');
  // najprv skontroluj, či je už uložené (meta existuje)
  if('caches' in window){
    const cache = await caches.open(CACHE_NAME);
    const matched = await cache.match(new Request(url));
    if(matched) return matched;
  }

  // ak nie, stiahneme súbor (stream) a urobíme cache.put + meta + enfore limit
  const resp = await fetch(new Request(url, { mode: 'cors' }));
  if(!resp.ok) throw new Error('Chyba pri sťahovaní: ' + resp.status);
  // Ak je to veľký súbor, zistíme veľkosť a prípadne odmietneme
  // Pozn: nie všetky odpovede obsahujú content-length; preto použijeme blob.size po clone
  const respClone = resp.clone();
  const blob = await respClone.blob();
  const size = blob.size || 0;
  if (size > MAX_SINGLE_FILE_BYTES) {
    throw new Error('Súbor je príliš veľký pre lokálne uloženie (' + (size/1024/1024).toFixed(1) + ' MB)');
  }

  // vložíme do cache: najprv response (potrebujeme origin/cors povolenie)
  if('caches' in window){
    const cache = await caches.open(CACHE_NAME);
    await cache.put(new Request(url), new Response(blob, { headers: resp.headers }));
    // ulož meta (size + ts)
    await putMeta(cache, url, size);
    // enforce LRU limit asynchrone (ale čakáme tu na dokončenie, aby užívateľ vedel stav)
    const eviction = await enforceCacheLimit(MAX_CACHE_BYTES);
    console.log('Cache stored', url, 'size', size, 'eviction:', eviction);
    // vráť originálnu Response (re-create z blob), aby volajúci mohol použiť
    return new Response(blob, { headers: resp.headers });
  }

  // fallback ak cache nie je dostupné: vráť response (blob) priamo
  return new Response(blob, { headers: resp.headers });
}


async function setAudioFromResponse(response){
  const blob = await response.blob();
  if(currentBlobUrl){ URL.revokeObjectURL(currentBlobUrl); currentBlobUrl = null; }
  currentBlobUrl = URL.createObjectURL(blob);
  audio.src = currentBlobUrl;
}

function computeDesiredPosition(){
  if(!audio.duration || !isFinite(audio.duration)) return 0;
  const now = Date.now(); const ref = parseReference();
  const offset = (now - ref) / 1000;
  if(offset < 0) return 0;
  return ((offset % audio.duration) + audio.duration) % audio.duration;
}

async function playSynchronized(){
  const name = selectEl.value; if(!name) { setStatus('vyberte meno'); return; }
  setStatus('pripravujem...');

  try{
    const resp = await fetchAndCacheIfNeeded(name);
    await setAudioFromResponse(resp);
  }catch(err){ console.error(err); setStatus('Chyba pri načítaní'); return; }

  // čakáme na metadata
  await new Promise(resolve => {
    if(!isFinite(audio.duration)){
      audio.addEventListener('loadedmetadata', function onm(){ audio.removeEventListener('loadedmetadata', onm); resolve(); });
    } else resolve();
  });

  const now = Date.now(); const ref = parseReference();
  const msToRef = ref - now;

  // ak pred referenčným časom: nastavíme currentTime=0 a počkáme
  if(msToRef > 0){
    audio.currentTime = 0; audio.pause(); setStatus('čeká sa na referenčný čas');
    clearTimeout(playPendingTimeout);
    playPendingTimeout = setTimeout(async ()=>{
      syncRequested = true;
      try{ await audio.play(); setStatus('hrá (synchronizované)'); startResyncLoop(); }catch(e){ setStatus('play blokovaný'); }
    }, msToRef);
    return;
  }

  // ak po referenčnom čase
  const desired = computeDesiredPosition();
  audio.currentTime = desired;
  syncRequested = true;
  try{ await audio.play(); setStatus('hrá (synchronizované)'); startResyncLoop(); }
  catch(e){ setStatus('play blokovaný'); }
}

function startResyncLoop(){
  if(resyncTimer) clearInterval(resyncTimer);
  resyncTimer = setInterval(()=>{
    if(audio.paused) return;
    const desired = computeDesiredPosition();
    if(Math.abs(audio.currentTime - desired) > RESYNC_TOLERANCE_S){
      audio.currentTime = desired;
    }
  }, RESYNC_INTERVAL_MS);
}

function stopPlaybackCleanup(){
  syncRequested = false;
  if(resyncTimer) { clearInterval(resyncTimer); resyncTimer = null; }
  if(playPendingTimeout) { clearTimeout(playPendingTimeout); playPendingTimeout = null; }
}

// STRIKTNE: zabráňte akejkoľvek forme manuálneho preskakovania alebo spustenia
audio.addEventListener('seeking', (e) => {
  const desired = computeDesiredPosition();
  if(Math.abs(audio.currentTime - desired) > 0.05){ audio.currentTime = desired; }
});

audio.addEventListener('timeupdate', ()=> {
  // aktualizujeme vizuálny panel
  updateProgressUI();

  // vynutíme synchronizovanú pozíciu ak treba
  const desired = computeDesiredPosition();
  if(Math.abs(audio.currentTime - desired) > RESYNC_TOLERANCE_S){
    audio.currentTime = desired;
    // aktualizujeme UI po korekcii
    updateProgressUI();
  }
});


// každý timeupdate aktualizuje vizuálny progress aj kontroluje synchronizáciu
audio.addEventListener('timeupdate', ()=> {
  // 1️⃣ aktualizujeme vizuálny panel (čas a progress)
  updateProgressUI();

  // 2️⃣ ak sa prehrávanie posunulo mimo tolerancie, vrátime ho na správne miesto
  const desired = computeDesiredPosition();
  if(Math.abs(audio.currentTime - desired) > RESYNC_TOLERANCE_S){
    audio.currentTime = desired;
    // pre istotu znovu obnovíme progress UI po korekcii
    updateProgressUI();
  }
});
// Ak sa prehrávanie spustí inak než cez náš sync flow -> prerobíme to na synchronizované spustenie
audio.addEventListener('play', () => {
  if(!syncRequested){
    // zastavíme okamžite a spustíme synchronizované prehrávanie
    audio.pause();
    stopPlaybackCleanup();
    // spustíme náš sync flow (vracia audio do správnej pozície)
    playSynchronized();
  } else {
    // autorizované spustenie - reset flag po krátkej dobe, aby ďalšie spontánne play boli znova kontrolované
    setTimeout(()=>{ syncRequested = false; }, 100);
  }
});


// Zakážeme kontextové menu (pravé tlačidlo) a bežné klávesy ktoré by mohli spustiť/presunúť prehrávanie
window.addEventListener('contextmenu', e => e.preventDefault());
window.addEventListener('keydown', e => {
  // space (32), left(37), up(38), right(39), down(40), k(75) atď. — zablokujeme ich ak nie je focus v input
  const blocked = [32,37,38,39,40,75];
  const target = e.target;
  const isInput = target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable);
  if(blocked.includes(e.keyCode) && !isInput){ e.preventDefault(); e.stopPropagation(); }
}, true);

// Ak používateľ klikne kdekoľvek, ak to vedie k neautorizovanému prehratiu, vrátime to späť (dodatočná bezpečnosť)
document.addEventListener('click', (e)=>{
  // žiadne akcie — len čisté monitorovanie
  if(audio.paused) return;
  const desired = computeDesiredPosition();
  if(Math.abs(audio.currentTime - desired) > 0.05) audio.currentTime = desired;
});

// UI event
playBtn.addEventListener('click', ()=>{ stopPlaybackCleanup(); playSynchronized(); });
// Stiahnuť a uložiť do Cache Storage (offline)
downloadBtn.addEventListener('click', async () => {
  const name = selectEl.value;
  if(!name){ setStatus('vyberte meno'); return; }
  downloadBtn.disabled = true;
  setStatus('sťahujem...');
  try{
    // fetchAndCacheIfNeeded už uloží do cache ak to nie je
    const resp = await fetchAndCacheIfNeeded(name);
    // explicitne nastavíme audio z response (takže je pripravené aj po reload)
    await setAudioFromResponse(resp);
    setStatus('stiahnuté a uložené do cache (offline pripravené)');
  }catch(err){
    console.error(err);
    setStatus('chyba pri sťahovaní: ' + (err.message || err));
  } finally {
    downloadBtn.disabled = false;
  }
});

// Vymazať cache pre zvolenú stopu
clearCacheBtn.addEventListener('click', async () => {
  const name = selectEl.value;
  if(!name){ setStatus('vyberte meno'); return; }
  const url = tracks[name];
  if(!('caches' in window)){ setStatus('Cache API nie je dostupné'); return; }
  try{
    const cache = await caches.open('synchronized-mp3-cache-v1');
    const deleted = await cache.delete(new Request(url));
    if(deleted) setStatus('vymazaná cache pre ' + name);
    else setStatus('cache pre ' + name + ' nebola nájdená');
  }catch(err){
    console.error(err);
    setStatus('chyba pri mazaní cache: ' + err.message);
  }
});

// init
(async function init(){ populateSelect(); setStatus('pripravený'); })();

</script>
</body>
</html>
